'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/1_logging-in/','title':"1 Logging In",'content':"Logging In There are two methods to log in. Use the method appropriate for your environment.\nSSO Login Because we can\u0026rsquo;t authenticate with name/password, we will use the sso flag to the cf login command. When we run the command, we\u0026rsquo;ll be prompted to visit a site, authenticate via our browser, and collect an authentication token that we will provide to our cf login command.\nHere is an example:\nuser@workstation:$ cf login --sso -a api.run.platform.com -o demo-org -s demo-space API endpoint: api.run.platform.com Temporary Authentication Code ( Get one at https://login.run.platform.gov/passcode )\u0026gt; Authenticating... OK Targeted org demo-org Targeted space demo-space API endpoint: https://api.run.platform.gov (API version: 2.137.0) User: user@pivotal.io Org: demo-org Space: demo-space Name/Password Login Simply log in with name \u0026amp; password.\nuser@workstation:$ cf login -a api.run.platform.com -u user@platform.com API endpoint: api.run.platform.com Password: Authenticating... OK Targeted org demo-org Targeted space demo-space API endpoint: https://api.run.platform.com (API version: 2.137.0) User: user@platform.com Org: demo-org Space: demo-space Confirm success by listing applications (since we\u0026rsquo;re new, we likely won\u0026rsquo;t have any apps so the list will be empty):\nuser@workstation:$ cf apps Getting apps in org demo-org / space demo-space as user@pivotal.io... OK No apps found "});index.add({'id':1,'href':'/docs/2_unpack-and-push-app/','title':"2 Unpack and Push App",'content':"Unpack The Demo App and cf push Unpack Create a directory, named workspace. Place the demo app tarball in there and unpack it.\nThis project has already been built and is ready for deployment. There is no need to build it.\nPush Push the app:\ncf push Profit Congrats! You just built and deployed your first application! See below for example output and an explanation of what just happened.\ncf push example output Below is an example of the output you will see when pushing your app. See the numbers in parenthesis and their corresponding explanation below the sample output for more details on this process.\nUsing manifest file /Users/username/Tools/PCF/demo2.0/attendees/manifest.yml // (1) Creating app attendees in org pivot-username / space development as username@pivotal.io... // (2) OK Creating route attendees-naturopathic-souple.cfapps.pez.pivotal.io... // (3) OK Binding attendees-naturopathic-souple.cfapps.pez.pivotal.io to attendees... // (4) OK Uploading attendees... Uploading app files from: /var/folders/k6/bg1q4mc50sl957cvyfw0s26r0000gp/T/unzipped-app942168724 Uploading 678.4K, 143 files // (5) Done uploading OK Starting app attendees in org pivot-username / space development as username@pivotal.io... Downloading python_buildpack... Downloading staticfile_buildpack... Downloading php_buildpack... Downloading java_buildpack_offline_v4... Downloading hwc_buildpack... Downloaded java_buildpack_offline_v4 Downloading java_buildpack_offline... Downloaded hwc_buildpack Downloading ruby_buildpack... Downloaded php_buildpack Downloading nodejs_buildpack... Downloaded python_buildpack Downloaded staticfile_buildpack Downloading go_buildpack... Downloading null_buildpack... Downloaded go_buildpack Downloading binary_buildpack... Downloaded java_buildpack_offline Downloading dotnet_core_buildpack... Downloaded ruby_buildpack Downloading tc_server_buildpack_offline... Downloaded null_buildpack Downloading azq_nodejs... Downloaded nodejs_buildpack Downloaded binary_buildpack Downloaded dotnet_core_buildpack Downloaded tc_server_buildpack_offline Downloaded azq_nodejs Creating container Successfully created container Downloading app package... Downloaded app package (34.4M) Staging... // (6) -----\u0026gt; Java Buildpack Version: v3.18 (offline) | https://github.com/cloudfoundry/java-buildpack.git#841ecb2 -----\u0026gt; Downloading Open Jdk JRE 1.8.0_131 from https://java-buildpack.cloudfoundry. org/openjdk/trusty/x86_64/openjdk-1.8.0_131.tar.gz (found in cache) // (7) Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.3s) -----\u0026gt; Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found in cache) Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K -----\u0026gt; Downloading Container Security Provider 1.5.0_RELEASE from https://java-buildpack.cloudfoundry.org/container-security-provider/container-security-provider-1.5.0_RELEASE.jar (found in cache) -----\u0026gt; Downloading Spring Auto Reconfiguration 1.11.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.11.0_RELEASE.jar (found in cache) Exit status 0 Staging complete Uploading droplet, build artifacts cache... // (8) Uploading build artifacts cache... Uploading droplet... Uploaded build artifacts cache (107B) Uploaded droplet (79.9M) Uploading complete Destroying container Successfully destroyed container 0 of 1 instances running, 1 starting 0 of 1 instances running, 1 starting 0 of 1 instances running, 1 starting 1 of 1 instances running App started OK App attendees was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-2.0.2_RELEASE -memorySizes=metaspace:64m..,stack:228k.. -memoryWeights=heap:65,metaspace:10,native:15,stack:10 -memoryInitials=heap:100%,metaspace:100% -stackThreads=300 -totMemory=$MEMORY_LIMIT) \u0026amp;\u0026amp; JAVA_OPTS=\u0026#34;-Djava.io.tmpdir=$TMPDIR-XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY-Djava.ext.dirs=$PWD/.java-buildpack/container_security_provider:$PWD/.java-buildpack/open_jdk_jre/lib/ext -Djava.security.properties=$PWD/.java-buildpack/security_providers/java.security\u0026#34; \u0026amp;\u0026amp; SERVER_PORT=$PORT eval exec $PWD/.java-buildpack/open_jdk_jre/bin/java $JAVA_OPTS -cp $PWD/. org.springframework.boot.loader.JarLauncher` // (9) Showing health and status for app attendees in org pivot-username / space development as username@pivotal.io... OK requested state: started instances: 1/1 usage: 1G x 1 instances urls: attendees-naturopathic-souple.cfapps.pez.pivotal.io last uploaded: Mon Aug 7 21:47:10 UTC 2017 stack: cflinuxfs2 buildpack: container-security-provider=1.5.0_RELEASE java-buildpack=v3.18-offline-https://github.com/cloudfoundry/java-buildpack.git#841ecb2 java-main open-jdk-like-jre=1.8.0_131 open-jdk-like-memory-calculator=2.0.2_RELEASE open-jdk-like-security-providers secur... state since cpu memory disk details #0 running 2017-08-07 04:48:08 PM 231.0% 498.1M of 1G 161.9M of 1G // (10) cf push, Explained   The CLI is using a manifest to provide necessary configuration details such as application name, memory to be allocated, and path to the application artifact. Take a look at manifest.yml to see how.\n  In most cases, the CLI indicates each Cloud Foundry API call as it happens. In this case, the CLI has created an application record for attendees in your assigned space.\n  All HTTP/HTTPS requests to applications will flow through Cloud Foundry\u0026rsquo;s front-end router called GoRouter. Here the CLI is creating a route with random word tokens inserted (again, see manifest.yml for a hint!) to prevent route collisions across the default PCF domain.\n  Now the CLI is binding the created route to the application. Routes can actually be bound to multiple applications to support techniques such as blue-green deployments.\n  The CLI finally uploads the application bits to PCF.\n  Now we begin the staging process. The Java Buildpack is responsible for assembling the runtime components necessary to run the application.\n  Here we see the version of the JRE that has been chosen and installed.\n  The complete package of your application and all of its necessary runtime components is called a droplet. Here the droplet is being uploaded to PCF\u0026rsquo;s internal blobstore so that it can be easily copied to one or more Diego Cells for execution.\n  The CLI tells you exactly what command and argument set was used to start your application.\n  Finally the CLI reports the current status of your application\u0026rsquo;s health. You can get the same output at any time by typing cf app attendees.\n  "});index.add({'id':2,'href':'/docs/3_logging-and-scaling/','title':"3 Logging and Scaling",'content':"Logging and Scaling With the Application Service, you can view the logs of your application in real time.\nAccess Application Logs Tail the logs:\ncf logs attendees Then open a browser and view the attendees application.\nObserve the log output when the attendees web page is refreshed. More logs are added!\nTo stop tailing logs, go to the terminal tailing the logs and send an interrupt (Control + c).\nAccess Application Events Events for the application can also be used to compliment the logs in determining what has occurred with an application.\ncf events attendees Scaling the Application Start tailing the logs again.\ncf logs attendees | grep \u0026#34;API\\|CELL\u0026#34; The above statement filters only matching log lines from the Cloud Controller and Cell components.\nIn another terminal window scale attendees.\ncf scale attendees -m 1G Observe log output. Stop tailing the logs. Scale attendees back to our original settings.\ncf scale attendees -m 768M Scale Out Browse to the Scale and HA page on the attendees application. Review the Application Environment Information.\nPress the Refresh button multiple times. All requests are going to one application instance.\nStart tailing the logs.\n[mac, linux] cf logs attendees | grep \u0026#34;API\\|CELL\u0026#34; [windows] cf logs attendees | findstr \u0026#34;API CELL\u0026#34; In another terminal windows, scale the attendees application.\ncf scale attendees -i 3 Observe log output. Then stop tailing the logs. Return to attendees in a web browser. Press the Refresh button several times. Observe the Addresses and Instance Index changing.\n"});index.add({'id':3,'href':'/docs/4_high-availability/','title':"4 High Availability",'content':"High Availability (HA) Application Service has 4 levels of HA (High Availability) that keep your applications and the underlying platform running.\n App Instance Availability Zone Process Machine  In this section, we will demonstrate one of them (App Instance). Failed application instances will be recovered.\nAt this time you should be running multiple instances of attendees. Confirm this with the following command:\ncf app attendees Return to attendees in a web browser and navigate to the Scale and HA page. Press the Refresh button. Confirm the application is running. Kill the app. Press the Kill button! Check the state of the app through the cf CLI.\ncf app attendees Sample output below (notice the requested state vs actual state). In this case, Application Service had already detected the failure and is starting a new instance.\nShowing health and status for app attendees in org mborges-org / space development as admin... name: attendees requested state: started instances: 3/3 usage: 768M x 3 instances routes: attendees-doxastic-progenitiveness.apps.pcf.homelab.lan last uploaded: Wed 09 Aug 17:18:22 CDT 2017 stack: cflinuxfs2 buildpack: container-security-provider=1.5.0_RELEASE java-buildpack=v3.18-offline-https://github.com/cloudfoundry/java-buildpack.git#841ecb2 java-main open-jdk-like-jre=1.8.0_131 open-jdk-like-memory-calculator=2.0.2_RELEASE open-jdk-like-security-providers secur... state since cpu memory disk details #0 starting 2017-08-10T00:31:23Z 0.0% 272.3M of 768M 161.9M of 1G #1 running 2017-08-10T00:30:24Z 6.3% 401.1M of 768M 161.9M of 1G #2 running 2017-08-10T00:30:32Z 2.1% 408.8M of 768M 161.9M of 1G Repeat this command as necessary until state = running. In your browser, Refresh the attendees application. The app is back up!\nA new, healthy app instance has been automatically provisioned to replace the failing one.\nView which instance was killed.\ncf events attendees Scale attendees back to our original settings.\ncf scale attendees -i 1 Questions  How do you recover failing application instances today? What effect does this have on your application design? How could you determine if your application has been crashing?  "});index.add({'id':4,'href':'/docs/5_namespacing/','title':"5 Namespacing",'content':"Namespacing You can explicitly define the name of your application without having a random phrase attached to it. For example, if you\u0026rsquo;re testing a feature branch, and you\u0026rsquo;ve named the branch after an issue assigned to it (say, issue number 1331), you can deploy your feature branch right next to existing workloads with no interruption of the existing apps.\nIn the manifest.yml, be sure random-route is set to false and add a -1331 to the end of your app name. Like so:\n--- applications: - name: attendees-1331 random-route: false . . . Now cf push again, and the platform will deploy a new application instance alongside your existing one.\nHere\u0026rsquo;s an example output showing the two apps deployed.\ncf apps Getting apps in org user-org / space development as user@platform.com... OK name requested state instances memory disk urls attendees started 1/1 768M 1G attendees.cfapps.io attendees-1331 started 1/1 768M 1G attendees-1331.cfapps.io Think about how you can take advantage of this in your CI/CD pipelines.\n"});index.add({'id':5,'href':'/docs/6_cert_auth/','title':"6 Cert Auth",'content':"Certificate Authentication The platform you\u0026rsquo;re using should be configured terminate TLS connections at the GoRouter (a component of the Platform). This happens before any traffic reaches your application. What this means for you is that you, as the developer, do not need to be concerned with Certificate Authority certs, chains, or handing authentication. If a user makes it to your application, they have already been verified to be a legitmate user (i.e. authenticated) by the platform.\nThis configuration is illustrated in the image below.\n After handling the TLS termination and user authentication, the Platform will take the PEM-encoded x509 user certificate and place it into the xfcc (or x-forward-client-cert) HTTP header. If you are using Spring, you can take advantage of Spring Security to automatically parse this certificate. Even without Spring, you can easily find this cert in the xfcc header.\nWe\u0026rsquo;re going to test this capability in this exercise with another sample application. This is a simple application that describes its envirionment (i.e. environment variables) as well as dumps all HTTP headers for easy human inspection.\nDownload the app behind this link\nNo building/compiling is necessary. Just unpack, cd into the cf-env directory, and cf push with the existing manifest.yml.\nAfter pushing, take the route that the Platform gives you and put it into your browser (remember to use https when putting the route into your browser). Once the app loads in your browser, click the \u0026ldquo;Headers\u0026rdquo; tab and confirm that the contents of the X-Forwarded-Client-Cert header are, indeed, the contents of your cert (i.e. what you loaded into your browser and chose to send to the app).\nThe below example is an image of what to expect.\n "});index.add({'id':6,'href':'/docs/7_cleanup/','title':"7 Cleanup",'content':"Cleanup Feel free to keep your app deployed for further work and research. When you\u0026rsquo;re finished, you can remove it with:\ncf delete attendees And you\u0026rsquo;re done! You\u0026rsquo;ve successfully completed the Application Service workshop!\n"});index.add({'id':7,'href':'/docs/','title':"Docs",'content':""});})();